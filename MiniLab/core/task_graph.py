"""
TaskGraph: DAG-based task planning and execution.

Provides a directed acyclic graph structure for task planning where:
- Bohr generates the graph during consultation based on user needs
- Nodes represent discrete tasks with owners, dependencies, and estimates
- The orchestrator executes nodes whose dependencies are satisfied
- Agents can add nodes during execution if new work is discovered

This replaces hardcoded workflow sequences with dynamic, Bohr-generated plans.
"""

from __future__ import annotations

import json
import shutil
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Optional


class TaskStatus(Enum):
    """Status of a task node."""
    PENDING = "pending"
    READY = "ready"  # Dependencies satisfied, can execute
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class TaskNode:
    """
    A single task in the execution graph.
    
    Attributes:
        id: Unique identifier for the task
        name: Human-readable task name
        description: What this task should accomplish
        owner: Agent responsible for this task (e.g., "hinton", "gould")
        dependencies: List of task IDs that must complete before this one
        estimated_tokens: Bohr's estimate of tokens needed (learned over time)
        status: Current execution status
        actual_tokens: Tokens actually consumed (recorded after completion)
        outputs: Key outputs produced by this task
        created_at: When the task was added to the graph
        completed_at: When the task finished
    """
    id: str
    name: str
    description: str
    owner: str
    dependencies: list[str] = field(default_factory=list)
    estimated_tokens: int = 0
    status: TaskStatus = TaskStatus.PENDING
    actual_tokens: int = 0
    outputs: dict[str, Any] = field(default_factory=dict)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    completed_at: Optional[str] = None
    error: Optional[str] = None
    
    def mark_ready(self) -> None:
        """Mark task as ready to execute."""
        if self.status == TaskStatus.PENDING:
            self.status = TaskStatus.READY
    
    def mark_in_progress(self) -> None:
        """Mark task as currently executing."""
        self.status = TaskStatus.IN_PROGRESS
    
    def mark_completed(self, actual_tokens: int = 0, outputs: Optional[dict] = None) -> None:
        """Mark task as successfully completed."""
        self.status = TaskStatus.COMPLETED
        self.actual_tokens = actual_tokens
        self.completed_at = datetime.now().isoformat()
        if outputs:
            self.outputs.update(outputs)
    
    def mark_failed(self, error: str) -> None:
        """Mark task as failed."""
        self.status = TaskStatus.FAILED
        self.error = error
        self.completed_at = datetime.now().isoformat()
    
    def mark_skipped(self, reason: str = "") -> None:
        """Mark task as skipped."""
        self.status = TaskStatus.SKIPPED
        self.error = reason or "Skipped"
        self.completed_at = datetime.now().isoformat()
    
    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "owner": self.owner,
            "dependencies": self.dependencies,
            "estimated_tokens": self.estimated_tokens,
            "status": self.status.value,
            "actual_tokens": self.actual_tokens,
            "outputs": self.outputs,
            "created_at": self.created_at,
            "completed_at": self.completed_at,
            "error": self.error,
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> TaskNode:
        """Deserialize from dictionary."""
        return cls(
            id=str(data["id"]),
            name=str(data["name"]),
            description=str(data.get("description", "")),
            owner=str(data.get("owner", "bohr")),
            dependencies=list(data.get("dependencies", [])),
            estimated_tokens=int(data.get("estimated_tokens", 0)),
            status=TaskStatus(data.get("status", "pending")),
            actual_tokens=int(data.get("actual_tokens", 0)),
            outputs=dict(data.get("outputs", {})),
            created_at=str(data.get("created_at", datetime.now().isoformat())),
            completed_at=data.get("completed_at"),
            error=data.get("error"),
        )


class TaskGraph:
    """
    A directed acyclic graph of tasks.
    
    The graph is generated by Bohr during consultation and defines
    the execution plan. The orchestrator executes tasks whose
    dependencies are satisfied, and agents can add new tasks if
    additional work is discovered during execution.
    """
    
    def __init__(self, project_name: str = ""):
        self.project_name = project_name
        self._nodes: dict[str, TaskNode] = {}
        self._created_at = datetime.now().isoformat()
        self._save_path: Optional[Path] = None  # Auto-persist after mutations
    
    @property
    def tasks(self) -> dict[str, TaskNode]:
        """Public accessor for task nodes (alias for _nodes)."""
        return self._nodes
    
    def set_save_path(self, path: Path) -> None:
        """Set the path for auto-persistence."""
        self._save_path = path
    
    def _auto_save(self) -> None:
        """Automatically persist to disk after mutations if save path is set."""
        if self._save_path:
            try:
                self.save(self._save_path)
            except Exception as e:
                # Log but don't fail - auto-save is best-effort
                import logging
                logging.warning(f"TaskGraph auto-save failed: {e}")
    
    def add_node(self, node: TaskNode) -> None:
        """
        Add a task node to the graph.
        
        Validates that dependencies reference existing nodes.
        """
        # Validate dependencies exist (or will exist)
        for dep_id in node.dependencies:
            if dep_id not in self._nodes:
                # Allow forward references during initial graph construction
                pass
        
        self._nodes[node.id] = node
        self._update_ready_status()
        self._auto_save()  # Persist immediately after adding task
    
    def add_task(
        self,
        task_id: str,
        name: str,
        description: str,
        owner: str,
        dependencies: Optional[list[str]] = None,
        estimated_tokens: int = 0,
    ) -> TaskNode:
        """
        Convenience method to create and add a task.
        
        Returns the created TaskNode.
        """
        node = TaskNode(
            id=task_id,
            name=name,
            description=description,
            owner=owner,
            dependencies=dependencies or [],
            estimated_tokens=estimated_tokens,
        )
        self.add_node(node)
        return node
    
    def get_node(self, task_id: str) -> Optional[TaskNode]:
        """Get a node by ID."""
        return self._nodes.get(task_id)
    
    def get_ready_tasks(self) -> list[TaskNode]:
        """
        Get all tasks that are ready to execute.
        
        A task is ready if:
        - Its status is PENDING or READY
        - All its dependencies are COMPLETED
        """
        self._update_ready_status()
        return [node for node in self._nodes.values() if node.status == TaskStatus.READY]
    
    def get_next_task(self) -> Optional[TaskNode]:
        """
        Get the next task to execute.
        
        Returns the first ready task, prioritizing by:
        1. Tasks with no dependencies (foundation tasks)
        2. Tasks with fewer estimated tokens (quick wins)
        """
        ready = self.get_ready_tasks()
        if not ready:
            return None
        
        # Sort by: dependency count (fewer first), then estimated tokens
        ready.sort(key=lambda t: (len(t.dependencies), t.estimated_tokens))
        return ready[0]
    
    def _update_ready_status(self) -> None:
        """Update READY status for all pending nodes."""
        completed_ids = {
            node_id for node_id, node in self._nodes.items()
            if node.status == TaskStatus.COMPLETED
        }
        
        for node in self._nodes.values():
            if node.status == TaskStatus.PENDING:
                # Check if all dependencies are complete
                deps_satisfied = all(
                    dep_id in completed_ids
                    for dep_id in node.dependencies
                )
                if deps_satisfied:
                    node.status = TaskStatus.READY
    
    def mark_completed(self, task_id: str, actual_tokens: int = 0, outputs: Optional[dict] = None) -> None:
        """Mark a task as completed and update dependent tasks."""
        node = self._nodes.get(task_id)
        if node:
            node.mark_completed(actual_tokens, outputs)
            self._update_ready_status()
            self._auto_save()  # Persist immediately
    
    def mark_failed(self, task_id: str, error: str) -> None:
        """Mark a task as failed."""
        node = self._nodes.get(task_id)
        if node:
            node.mark_failed(error)
            self._auto_save()  # Persist immediately
    
    def is_complete(self) -> bool:
        """Check if all tasks are completed (or skipped/failed)."""
        terminal_statuses = {TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.SKIPPED}
        return all(node.status in terminal_statuses for node in self._nodes.values())
    
    def get_progress(self) -> dict[str, Any]:
        """Get execution progress summary."""
        total = len(self._nodes)
        by_status = {}
        for status in TaskStatus:
            count = sum(1 for n in self._nodes.values() if n.status == status)
            if count > 0:
                by_status[status.value] = count
        
        completed = by_status.get("completed", 0)
        
        # Token tracking
        estimated_total = sum(n.estimated_tokens for n in self._nodes.values())
        actual_used = sum(n.actual_tokens for n in self._nodes.values() if n.actual_tokens > 0)
        remaining_estimated = sum(
            n.estimated_tokens for n in self._nodes.values()
            if n.status not in {TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.SKIPPED}
        )
        
        return {
            "total_tasks": total,
            "completed": completed,
            "percent_complete": (completed / total * 100) if total > 0 else 0,
            "by_status": by_status,
            "estimated_total_tokens": estimated_total,
            "actual_tokens_used": actual_used,
            "remaining_estimated_tokens": remaining_estimated,
        }
    
    def get_tasks_for_agent(self, agent_id: str) -> list[TaskNode]:
        """Get all tasks assigned to a specific agent."""
        return [node for node in self._nodes.values() if node.owner == agent_id]
    
    def to_dict(self) -> dict[str, Any]:
        """Serialize the entire graph."""
        return {
            "project_name": self.project_name,
            "created_at": self._created_at,
            "nodes": {node_id: node.to_dict() for node_id, node in self._nodes.items()},
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> TaskGraph:
        """Deserialize from dictionary."""
        graph = cls(project_name=str(data.get("project_name", "")))
        graph._created_at = str(data.get("created_at", datetime.now().isoformat()))
        
        for node_data in data.get("nodes", {}).values():
            graph.add_node(TaskNode.from_dict(node_data))
        
        return graph
    
    @classmethod
    def from_bohr_plan(cls, plan_json: dict[str, Any], project_name: str = "") -> TaskGraph:
        """
        Create a TaskGraph from Bohr's consultation output.
        
        Expected format:
        {
            "tasks": [
                {
                    "id": "literature_review",
                    "name": "Literature Review",
                    "description": "Search for relevant papers...",
                    "owner": "gould",
                    "dependencies": [],
                    "estimated_tokens": 80000
                },
                ...
            ]
        }
        """
        graph = cls(project_name=project_name)
        
        for task_data in plan_json.get("tasks", []):
            node = TaskNode.from_dict(task_data)
            graph.add_node(node)
        
        return graph
    
    def to_summary(self) -> str:
        """Generate a human-readable summary of the graph."""
        lines = [f"Task Graph: {self.project_name}", "=" * 50]
        
        progress = self.get_progress()
        lines.append(f"Progress: {progress['completed']}/{progress['total_tasks']} tasks completed")
        lines.append(f"Tokens: {progress['actual_tokens_used']:,} used, {progress['remaining_estimated_tokens']:,} estimated remaining")
        lines.append("")
        
        # Group by status
        for status in [TaskStatus.IN_PROGRESS, TaskStatus.READY, TaskStatus.PENDING, TaskStatus.COMPLETED]:
            tasks = [n for n in self._nodes.values() if n.status == status]
            if tasks:
                lines.append(f"{status.value.upper()}:")
                for task in tasks:
                    deps = f" (after: {', '.join(task.dependencies)})" if task.dependencies else ""
                    tokens = f" [{task.estimated_tokens:,} tokens]" if task.estimated_tokens else ""
                    lines.append(f"  • {task.name} ({task.owner}){deps}{tokens}")
                lines.append("")
        
        return "\n".join(lines)
    
    def save(self, path: Path) -> None:
        """Save graph to file."""
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)
    
    @classmethod
    def load(cls, path: Path) -> Optional[TaskGraph]:
        """Load graph from file."""
        if not path.exists():
            return None
        try:
            with open(path) as f:
                data = json.load(f)
            return cls.from_dict(data)
        except (json.JSONDecodeError, KeyError):
            return None
    
    def to_dot(self, rankdir: str = "LR") -> str:
        """
        Render the TaskGraph to a Graphviz DOT string.
        
        Args:
            rankdir: Graph direction - "LR" (left-right), "TB" (top-bottom)
            
        Returns:
            DOT format string
        """
        return task_graph_to_dot(self, rankdir=rankdir)
    
    def render_png(self, dot_path: Path, png_path: Optional[Path] = None) -> Path:
        """
        Render the TaskGraph to a PNG image.
        
        Requires Graphviz to be installed.
        
        Args:
            dot_path: Path to write the DOT file
            png_path: Path for the PNG output (defaults to dot_path with .png suffix)
            
        Returns:
            Path to the generated PNG file
        """
        # Write DOT first
        write_task_graph_dot(self, dot_path)
        # Render to PNG
        return render_task_graph_png(dot_path, png_path)
    
    def export_visuals(self, out_dir: Path, base_name: str = "task_dag") -> dict[str, Path]:
        """
        Export both DOT and PNG visualizations.
        
        Args:
            out_dir: Directory for output files
            base_name: Base filename (without extension)
            
        Returns:
            Dict with 'dot' and 'png' paths
        """
        return export_task_graph_visuals(self, out_dir=out_dir, base_name=base_name)
    
    def validate(self) -> None:
        """
        Validate the TaskGraph is a proper DAG.
        
        Raises:
            TaskGraphValidationError: If validation fails
        """
        validate_task_graph(self)


class TaskGraphValidationError(ValueError):
    """Raised when a TaskGraph fails basic DAG integrity checks."""

    def __init__(
        self,
        message: str,
        *,
        missing_dependencies: Optional[dict[str, list[str]]] = None,
        cycle: Optional[list[tuple[str, str]]] = None,
    ):
        super().__init__(message)
        self.missing_dependencies = missing_dependencies or {}
        self.cycle = cycle


def _dot_escape(text: str) -> str:
    return (
        str(text)
        .replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
    )


def _taskgraph_status_color(status: TaskStatus) -> str:
    # Keep this conservative and Graphviz-default friendly.
    return {
        TaskStatus.PENDING: "gray70",
        TaskStatus.READY: "gold",
        TaskStatus.IN_PROGRESS: "lightskyblue",
        TaskStatus.COMPLETED: "palegreen",
        TaskStatus.FAILED: "lightcoral",
        TaskStatus.SKIPPED: "gray85",
    }.get(status, "white")


def _taskgraph_node_label(node: TaskNode) -> str:
    parts = [node.name]
    if node.owner:
        parts.append(f"[{node.owner}]")
    if node.status:
        parts.append(f"({node.status.value})")
    return "\n".join(parts)  # Actual newlines - _dot_escape will convert to \\n for DOT format


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _safe_run_graphviz_dot(dot_path: Path, png_path: Path) -> None:
    dot_exe = shutil.which("dot")
    if not dot_exe:
        raise RuntimeError(
            "Graphviz is required to render TaskGraph PNGs but 'dot' was not found on PATH. "
            "Install Graphviz into the 'minilab' environment (recommended via conda-forge): "
            "`micromamba install -n minilab -c conda-forge graphviz`"
        )
    try:
        proc = subprocess.run(
            [dot_exe, "-Tpng", str(dot_path), "-o", str(png_path)],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except subprocess.CalledProcessError as e:
        stderr = (e.stderr or "").strip()
        if len(stderr) > 2_000:
            stderr = stderr[:2_000] + "…"
        raise RuntimeError(
            f"Graphviz 'dot' failed while rendering {dot_path.name} -> {png_path.name}: {stderr or 'unknown error'}"
        ) from e


def _taskgraph_build_digraph(nodes: dict[str, TaskNode]):
    import networkx as nx

    g = nx.DiGraph()
    for node_id in nodes:
        g.add_node(node_id)
    for node_id, node in nodes.items():
        for dep in node.dependencies:
            # Edge direction: dependency -> node
            if dep in nodes:
                g.add_edge(dep, node_id)
    return g


def _taskgraph_find_missing_dependencies(nodes: dict[str, TaskNode]) -> dict[str, list[str]]:
    missing: dict[str, list[str]] = {}
    node_ids = set(nodes.keys())
    for node_id, node in nodes.items():
        missing_deps = [d for d in node.dependencies if d not in node_ids]
        if missing_deps:
            missing[node_id] = missing_deps
    return missing


def _taskgraph_find_cycle(nodes: dict[str, TaskNode]) -> Optional[list[tuple[str, str]]]:
    import networkx as nx

    g = _taskgraph_build_digraph(nodes)
    if nx.is_directed_acyclic_graph(g):
        return None
    try:
        return list(nx.find_cycle(g, orientation="original"))
    except Exception:
        return None


def _taskgraph_toposort(nodes: dict[str, TaskNode]) -> list[str]:
    import networkx as nx

    g = _taskgraph_build_digraph(nodes)
    return list(nx.topological_sort(g))


def _format_cycle(cycle: list[tuple[str, str]]) -> str:
    # Example entries from networkx: (u, v, 'forward') or (u, v)
    edges: list[tuple[str, str]] = []
    for item in cycle:
        if isinstance(item, tuple) and len(item) >= 2:
            edges.append((str(item[0]), str(item[1])))
    if not edges:
        return "(cycle details unavailable)"
    path = " -> ".join([edges[0][0]] + [b for (_, b) in edges])
    return path


def validate_task_graph(graph: TaskGraph) -> None:
    """Validate that a TaskGraph is well-formed as an executable DAG."""
    missing = _taskgraph_find_missing_dependencies(graph.tasks)
    if missing:
        examples = ", ".join([f"{k}: {v}" for k, v in list(missing.items())[:3]])
        raise TaskGraphValidationError(
            f"TaskGraph has missing dependencies (examples: {examples})",
            missing_dependencies=missing,
        )

    cycle = _taskgraph_find_cycle(graph.tasks)
    if cycle:
        raise TaskGraphValidationError(
            f"TaskGraph contains a dependency cycle: {_format_cycle(cycle)}",
            cycle=cycle,
        )


def task_graph_to_dot(graph: TaskGraph, *, rankdir: str = "LR") -> str:
    """Render the TaskGraph to a Graphviz DOT string."""
    lines: list[str] = []
    lines.append("digraph TaskGraph {")
    lines.append(f"  rankdir={_dot_escape(rankdir)};")
    lines.append("  node [shape=box, style=filled, fontname=Helvetica];")
    lines.append("  edge [color=gray50];")

    # Prefer a stable order for deterministic output
    try:
        order = _taskgraph_toposort(graph.tasks)
    except Exception:
        order = sorted(graph.tasks.keys())

    for node_id in order:
        node = graph.tasks[node_id]
        label = _dot_escape(_taskgraph_node_label(node))
        fill = _taskgraph_status_color(node.status)
        lines.append(f'  "{_dot_escape(node_id)}" [label="{label}", fillcolor="{fill}"];')

    for node_id in order:
        node = graph.tasks[node_id]
        for dep in node.dependencies:
            if dep in graph.tasks:
                lines.append(f'  "{_dot_escape(dep)}" -> "{_dot_escape(node_id)}";')

    lines.append("}")
    return "\n".join(lines) + "\n"


def write_task_graph_dot(graph: TaskGraph, dot_path: Path) -> Path:
    _ensure_parent(dot_path)
    dot_path.write_text(task_graph_to_dot(graph))
    return dot_path


def render_task_graph_png(dot_path: Path, png_path: Optional[Path] = None) -> Path:
    png_path = png_path or dot_path.with_suffix(".png")
    _ensure_parent(png_path)
    _safe_run_graphviz_dot(dot_path, png_path)
    if not png_path.exists():
        raise RuntimeError(f"Graphviz reported success but PNG was not created: {png_path}")
    return png_path


def export_task_graph_visuals(
    graph: TaskGraph,
    *,
    out_dir: Path,
    base_name: str = "task_graph",
    render_png: bool = True,
) -> dict[str, Path]:
    """Write DOT (and optionally PNG) for the task graph."""
    out_dir.mkdir(parents=True, exist_ok=True)
    dot_path = out_dir / f"{base_name}.dot"
    write_task_graph_dot(graph, dot_path)
    artifacts: dict[str, Path] = {"dot": dot_path}
    if render_png:
        artifacts["png"] = render_task_graph_png(dot_path)
    return artifacts
